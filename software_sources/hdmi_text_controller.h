#ifndef HDMI_TEXT_CONTROLLER_H
#define HDMI_TEXT_CONTROLLER_H

/****************** Include Files ********************/
#include "xil_types.h"
#include "xparameters.h"
#include "xstatus.h"

typedef struct __attribute__((packed)) {
  uint16_t vertices[9];
  uint8_t color;
  int32_t r_area;
} DATA;

// TODO: SET THIS LATER
// volatile bool *vsync;

// TODO: Maybe change this
// static volatile DATA* data = (DATA*)
// XPAR_HDMI_TEXT_CONTROLLER_0_AXI_BASEADDR;
//  addr[0] = v1.y, v1.x
//  addr[1] = v2.x, v1.z
//  addr[2] = v2.z, v1.y
//  addr[3] = v3.y, v3.x
//  addr[4] = color, v3.z
//  addr[5] = r_area
// static volatile uint32_t *addr = XPAR_HDMI_TEXT_CONTROLLER_0_AXI_BASEADDR;

// Both meshes generated by AI
// Cornell Box Mesh
// Vertex1, Vertex2, Vertex3, RRRGGGBB
// static const uint8_t cornell_box[][10] = {
//    // Floor (V2 and V3 swapped)
//    {0,0,0,   255,0,255,   255,0,0,   0xFF},
//    {0,0,0,   0,0,255,   255,0,255,   0xFF},
//    // Ceiling (V2 and V3 swapped)
//    {0,255,0,   255,255,0,   255,255,255,   0x1F},
//    {0,255,0,   255,255,255,   0,255,255,   0x1F},
//    // Left wall (V2 and V3 swapped)
//    {0,0,0,   0,255,255,   0,0,255,   0x05},
//    {0,0,0,   0,255,0,   0,255,255,   0x05},
//    // Right wall (V2 and V3 swapped)
//    {255,0,0,   255,255,255,   255,255,0,   0x1C},
//    {255,0,0,   255,0,255,   255,255,255,   0x1C},
//    // Back wall (V2 and V3 swapped)
//    {0,0,255,   255,255,255,   255,0,255,   0x7F},
//    {0,0,255,   0,255,255,   255,255,255,   0x7F},
//    // Small cube (Indices 12, 13, 16, 17, 20, 21 swapped)
//    {51,0,102,   102,0,102,   102,0,153,   0x9A},
//    {51,0,102,   102,0,153,   51,0,153,   0x9A},
//    {51,51,102,   102,51,102,   102,51,153,   0x9A},
//    {51,51,102,   102,51,153,   51,51,153,   0x9A},
//    {51,0,102,   51,51,102,   102,51,102,   0x9A},
//    {51,0,102,   102,51,102,   102,0,102,   0x9A},
//    {51,0,153,   102,51,153,   102,0,153,   0x9A},
//    {51,0,153,   51,51,153,   102,51,153,   0x9A},
//    {51,0,102,   51,0,153,   51,51,153,   0x9A},
//    {51,0,102,   51,51,153,   51,51,102,   0x9A},
//    {102,0,102,   102,51,153,   102,51,102,   0x9A},
//    {102,0,102,   102,0,153,   102,51,153,   0x9A},
//    // Tall cube (Indices 24, 25, 28, 29, 32, 33 swapped)
//    {153,0,179,   204,0,179,   204,0,230,   0x2B},
//    {153,0,179,   204,0,230,   153,0,230,   0x2B},
//    {153,128,179,   204,128,179,   204,128,230,   0x2B},
//    {153,128,179,   204,128,230,   153,128,230,   0x2B},
//    {153,0,179,   153,128,179,   204,128,179,   0x2B},
//    {153,0,179,   204,128,179,   204,0,179,   0x2B},
//    {153,0,230,   204,128,230,   204,0,230,   0x2B},
//    {153,0,230,   153,128,230,   204,128,230,   0x2B},
//    {153,0,179,   153,0,230,   153,128,230,   0x2B},
//    {153,0,179,   153,128,230,   153,128,179,   0x2B},
//    {204,0,179,   204,128,230,   204,128,179,   0xFF},
//    {204,0,179,   204,0,230,   204,128,230,   0xFF},
//};
// Above and below mesh generated by AI
// Asked Claude: "Generate a mesh for the cornell box as a C array of arrays of size 10.
// The inner array should have the format: {v1x, v1y, v1z, v2x, v2y, v2z, color} where
// color is RRRGGGBB (an 8-bit value)
static const uint8_t cornell_box[][10] = {
    // Floor (white)
    {0, 0, 0, 255, 0, 0, 255, 0, 255, 0xFF},
    {0, 0, 0, 255, 0, 255, 0, 0, 255, 0x4A},
    // Ceiling (white)
    {0, 255, 0, 255, 255, 255, 255, 255, 0, 0xE8},
    {0, 255, 0, 0, 255, 255, 255, 255, 255, 0x73},
    // Left wall (red)
    {0, 0, 0, 0, 0, 255, 0, 255, 255, 0x47},
    {0, 0, 0, 0, 255, 255, 0, 255, 0, 0x67},
    // Right wall (green)
    {255, 0, 0, 255, 255, 0, 255, 255, 255, 0x1C},
    {255, 0, 0, 255, 255, 255, 255, 0, 255, 0x8f},
    // Back wall (white)
    {0, 0, 255, 255, 0, 255, 255, 255, 255, 0xf3},
    {0, 0, 255, 255, 255, 255, 0, 255, 255, 0xa2},
    // Small cube (white)
    {51, 0, 102, 102, 0, 102, 102, 0, 153, 0xb7},
    {51, 0, 102, 102, 0, 153, 51, 0, 153, 0xb0},
    {51, 51, 102, 102, 51, 153, 102, 51, 102, 0x0b},
    {51, 51, 102, 51, 51, 153, 102, 51, 153, 0xab},
    {51, 0, 102, 51, 51, 102, 102, 51, 102, 0xcd},
    {51, 0, 102, 102, 51, 102, 102, 0, 102, 0xef},
    {51, 0, 153, 102, 0, 153, 102, 51, 153, 0x01},
    {51, 0, 153, 102, 51, 153, 51, 51, 153, 0x12},
    {51, 0, 102, 51, 0, 153, 51, 51, 153, 0x23},
    {51, 0, 102, 51, 51, 153, 51, 51, 102, 0x7c},
    {102, 0, 102, 102, 51, 102, 102, 51, 153, 0x3d},
    {102, 0, 102, 102, 51, 153, 102, 0, 153, 0xd3},
    // Tall cube (blue)
    {153, 0, 179, 204, 0, 179, 204, 0, 230, 0x7a},
    {153, 0, 179, 204, 0, 230, 153, 0, 230, 0xb1},
    {153, 128, 179, 204, 128, 230, 204, 128, 179, 0xd1},
    {153, 128, 179, 153, 128, 230, 204, 128, 230, 0xea},
    {153, 0, 179, 153, 128, 179, 204, 128, 179, 0x03},
    {153, 0, 179, 204, 128, 179, 204, 0, 179, 0x13},
    {153, 0, 230, 204, 0, 230, 204, 128, 230, 0x9c},
    {153, 0, 230, 204, 128, 230, 153, 128, 230, 0x5a},
    {153, 0, 179, 153, 0, 230, 153, 128, 230, 0x95},
    {153, 0, 179, 153, 128, 230, 153, 128, 179, 0x74},
    {204, 0, 179, 204, 128, 179, 204, 128, 230, 0x83},
    {204, 0, 179, 204, 128, 230, 204, 0, 230, 0xfa},
};

static const int cornell_box_triangle_count =
    sizeof(cornell_box) / sizeof(cornell_box[0]);

// Sin lookup table generated by AI
static const float sin_lut[256] = {
    0.000000f,  0.024541f,  0.049068f,  0.073565f,  0.098017f,  0.122411f,
    0.146730f,  0.170962f,  0.195090f,  0.219101f,  0.242980f,  0.266713f,
    0.290285f,  0.313682f,  0.336890f,  0.359895f,  0.382683f,  0.405241f,
    0.427555f,  0.449611f,  0.471397f,  0.492898f,  0.514103f,  0.534998f,
    0.555570f,  0.575808f,  0.595699f,  0.615232f,  0.634393f,  0.653173f,
    0.671559f,  0.689541f,  0.707107f,  0.724247f,  0.740951f,  0.757209f,
    0.773010f,  0.788346f,  0.803208f,  0.817585f,  0.831470f,  0.844854f,
    0.857729f,  0.870087f,  0.881921f,  0.893224f,  0.903989f,  0.914210f,
    0.923880f,  0.932993f,  0.941544f,  0.949528f,  0.956940f,  0.963776f,
    0.970031f,  0.975702f,  0.980785f,  0.985278f,  0.989177f,  0.992480f,
    0.995185f,  0.997290f,  0.998795f,  0.999699f,  1.000000f,  0.999699f,
    0.998795f,  0.997290f,  0.995185f,  0.992480f,  0.989177f,  0.985278f,
    0.980785f,  0.975702f,  0.970031f,  0.963776f,  0.956940f,  0.949528f,
    0.941544f,  0.932993f,  0.923880f,  0.914210f,  0.903989f,  0.893224f,
    0.881921f,  0.870087f,  0.857729f,  0.844854f,  0.831470f,  0.817585f,
    0.803208f,  0.788346f,  0.773010f,  0.757209f,  0.740951f,  0.724247f,
    0.707107f,  0.689541f,  0.671559f,  0.653173f,  0.634393f,  0.615232f,
    0.595699f,  0.575808f,  0.555570f,  0.534998f,  0.514103f,  0.492898f,
    0.471397f,  0.449611f,  0.427555f,  0.405241f,  0.382683f,  0.359895f,
    0.336890f,  0.313682f,  0.290285f,  0.266713f,  0.242980f,  0.219101f,
    0.195090f,  0.170962f,  0.146730f,  0.122411f,  0.098017f,  0.073565f,
    0.049068f,  0.024541f,  0.000000f,  -0.024541f, -0.049068f, -0.073565f,
    -0.098017f, -0.122411f, -0.146730f, -0.170962f, -0.195090f, -0.219101f,
    -0.242980f, -0.266713f, -0.290285f, -0.313682f, -0.336890f, -0.359895f,
    -0.382683f, -0.405241f, -0.427555f, -0.449611f, -0.471397f, -0.492898f,
    -0.514103f, -0.534998f, -0.555570f, -0.575808f, -0.595699f, -0.615232f,
    -0.634393f, -0.653173f, -0.671559f, -0.689541f, -0.707107f, -0.724247f,
    -0.740951f, -0.757209f, -0.773010f, -0.788346f, -0.803208f, -0.817585f,
    -0.831470f, -0.844854f, -0.857729f, -0.870087f, -0.881921f, -0.893224f,
    -0.903989f, -0.914210f, -0.923880f, -0.932993f, -0.941544f, -0.949528f,
    -0.956940f, -0.963776f, -0.970031f, -0.975702f, -0.980785f, -0.985278f,
    -0.989177f, -0.992480f, -0.995185f, -0.997290f, -0.998795f, -0.999699f,
    -1.000000f, -0.999699f, -0.998795f, -0.997290f, -0.995185f, -0.992480f,
    -0.989177f, -0.985278f, -0.980785f, -0.975702f, -0.970031f, -0.963776f,
    -0.956940f, -0.949528f, -0.941544f, -0.932993f, -0.923880f, -0.914210f,
    -0.903989f, -0.893224f, -0.881921f, -0.870087f, -0.857729f, -0.844854f,
    -0.831470f, -0.817585f, -0.803208f, -0.788346f, -0.773010f, -0.757209f,
    -0.740951f, -0.724247f, -0.707107f, -0.689541f, -0.671559f, -0.653173f,
    -0.634393f, -0.615232f, -0.595699f, -0.575808f, -0.555570f, -0.534998f,
    -0.514103f, -0.492898f, -0.471397f, -0.449611f, -0.427555f, -0.405241f,
    -0.382683f, -0.359895f, -0.336890f, -0.313682f, -0.290285f, -0.266713f,
    -0.242980f, -0.219101f, -0.195090f, -0.170962f, -0.146730f, -0.122411f,
    -0.098017f, -0.073565f, -0.049068f, -0.024541f

};

#define LUT_SIZE 256
#define LUT_SIZE_F 256.0f

// Fast sin approximation with linear interpolation
// Generated by AI
float sin_lookup(float radians) {
  // Normalize to [0, 2π)
  while (radians < 0.0f)
    radians += 6.283185f;
  while (radians >= 6.283185f)
    radians -= 6.283185f;

  // Map to table index (floating point)
  float index_f = (radians / 6.283185f) * LUT_SIZE_F;
  uint32_t index0 = (uint32_t)index_f;
  uint32_t index1 = (index0 + 1) & (LUT_SIZE - 1); // Wrap around

  // Linear interpolation
  float frac = index_f - (float)index0;
  return sin_lut[index0] + frac * (sin_lut[index1] - sin_lut[index0]);
}

float cos_lookup(float radians) {
  // cos(x) = sin(x + π/2)
  return sin_lookup(radians + 1.570796f);
}

/**************************** Type Definitions *****************************/
/**
 *
 * Write a value to a HDMI_TEXT_CONTROLLER register. A 32 bit write is
 * performed. If the component is implemented in a smaller width, only the least
 * significant data is written.
 *
 * @param   BaseAddress is the base address of the HDMI_TEXT_CONTROLLERdevice.
 * @param   RegOffset is the register offset from the base to write to.
 * @param   Data is the data written to the register.
 *
 * @return  None.
 *
 * @note
 * C-style signature:
 * 	void HDMI_TEXT_CONTROLLER_mWriteReg(u32 BaseAddress, unsigned RegOffset,
 * u32 Data)
 *
 */
#define HDMI_TEXT_CONTROLLER_mWriteReg(BaseAddress, RegOffset, Data)           \
  Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))

/**
 *
 * Read a value from a HDMI_TEXT_CONTROLLER register. A 32 bit read is
 * performed. If the component is implemented in a smaller width, only the least
 * significant data is read from the register. The most significant data
 * will be read as 0.
 *
 * @param   BaseAddress is the base address of the HDMI_TEXT_CONTROLLER device.
 * @param   RegOffset is the register offset from the base to write to.
 *
 * @return  Data is the data from the register.
 *
 * @note
 * C-style signature:
 * 	u32 HDMI_TEXT_CONTROLLER_mReadReg(u32 BaseAddress, unsigned RegOffset)
 *
 */
//#define HDMI_TEXT_CONTROLLER_mReadReg(BaseAddress, RegOffset) \
//    Xil_In32((BaseAddress) + (RegOffset))

/************************** Function Prototypes ****************************/
/**
 *
 * Run a self-test on the driver/device. Note this may be a destructive test if
 * resets of the device are performed.
 *
 * If the hardware system is not built correctly, this function may never
 * return to the caller.
 *
 * @param   baseaddr_p is the base address of the HDMI_TEXT_CONTROLLER instance
 * to be worked on.
 *
 * @return
 *
 *    - XST_SUCCESS   if all self-test code passed
 *    - XST_FAILURE   if any self-test code failed
 *
 * @note    Caching must be turned off for this function to work.
 * @note    Self test may fail if data memory and device are not on the same
 * bus.
 *
 */

#endif // HDMI_TEXT_CONTROLLER_H
